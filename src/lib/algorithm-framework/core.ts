/**
 * Algorithm Framework
 * Inspired by QuantConnect LEAN Algorithm Framework
 *
 * Modular architecture for building trading algorithms:
 * - Universe Selection: Select assets to trade
 * - Alpha Model: Generate trading signals
 * - Portfolio Construction: Determine position sizes
 * - Risk Management: Apply risk controls
 * - Execution Model: Execute trades efficiently
 *
 * This framework allows each component to be independently
 * developed, tested, and combined with other components.
 */

// ============================================================================
// CORE TYPES
// ============================================================================

/**
 * Symbol represents a tradeable asset
 */
export interface Symbol {
  ticker: string;
  exchange: string;
  assetClass: 'crypto' | 'equity' | 'forex' | 'futures' | 'commodity';
  baseCurrency?: string;
  quoteCurrency?: string;
}

/**
 * Market data for a single point in time
 */
export interface MarketData {
  symbol: Symbol;
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  bid?: number;
  ask?: number;
  bidSize?: number;
  askSize?: number;
}

/**
 * Slice contains all market data at a point in time
 */
export interface Slice {
  timestamp: number;
  data: Map<string, MarketData>;
  get(symbol: Symbol): MarketData | undefined;
  has(symbol: Symbol): boolean;
}

/**
 * Trading signal (alpha) generated by Alpha Model
 */
export interface Alpha {
  symbol: Symbol;
  direction: 'up' | 'down' | 'flat';
  magnitude: number; // Signal strength (0-1)
  confidence: number; // Confidence level (0-1)
  source: string; // Alpha model name
  timestamp: number;
  insights?: Map<string, number>; // Additional insights
}

/**
 * Portfolio target from Portfolio Construction
 */
export interface PortfolioTarget {
  symbol: Symbol;
  quantity: number;
  targetValue?: number;
  targetWeight?: number;
  reason: string;
}

/**
 * Order for execution
 */
export interface Order {
  id: string;
  symbol: Symbol;
  type: 'market' | 'limit' | 'stop' | 'stop_limit' | 'trailing_stop';
  side: 'buy' | 'sell';
  quantity: number;
  price?: number;
  stopPrice?: number;
  timeInForce: 'GTC' | 'IOC' | 'FOK' | 'DAY';
  status: 'pending' | 'submitted' | 'filled' | 'cancelled' | 'rejected';
  filledQuantity: number;
  filledPrice: number;
  timestamp: number;
  tag?: string;
}

/**
 * Position in portfolio
 */
export interface FrameworkPosition {
  symbol: Symbol;
  quantity: number;
  averagePrice: number;
  marketPrice: number;
  marketValue: number;
  unrealizedPnL: number;
  unrealizedPnLPercent: number;
  side: 'long' | 'short' | 'flat';
}

/**
 * Algorithm context passed to all components
 */
export interface AlgorithmContext {
  // Time
  time: number;
  timezone: string;

  // Portfolio
  portfolio: {
    totalValue: number;
    cash: number;
    positions: FrameworkPosition[];
    unrealizedPnL: number;
    realizedPnL: number;
  };

  // Securities
  securities: Map<string, {
    symbol: Symbol;
    price: number;
    volume: number;
    bid: number;
    ask: number;
    volatility?: number;
  }>;

  // Orders
  orders: {
    pending: Order[];
    filled: Order[];
    cancelled: Order[];
  };

  // History access
  history: (symbol: Symbol, periods: number, resolution: string) => MarketData[];

  // Logging
  log: (message: string) => void;
  debug: (message: string) => void;
  error: (message: string) => void;
}

// ============================================================================
// UNIVERSE SELECTION
// ============================================================================

/**
 * Universe Selection Model
 * Selects which assets to include in the algorithm
 */
export interface IUniverseSelectionModel {
  name: string;
  selectUniverses(context: AlgorithmContext): Promise<Symbol[]>;
  onSecuritiesChanged?: (
    additions: Symbol[],
    removals: Symbol[]
  ) => Promise<void>;
}

/**
 * Manual Universe Selection
 * User-specified list of symbols
 */
export class ManualUniverseSelectionModel implements IUniverseSelectionModel {
  name = 'ManualUniverseSelection';
  private symbols: Symbol[];

  constructor(symbols: Symbol[]) {
    this.symbols = symbols;
  }

  async selectUniverses(): Promise<Symbol[]> {
    return this.symbols;
  }
}

/**
 * Dynamic Universe Selection
 * Selects assets based on criteria
 */
export class DynamicUniverseSelectionModel implements IUniverseSelectionModel {
  name = 'DynamicUniverseSelection';

  constructor(
    private options: {
      minVolume?: number;
      minPrice?: number;
      maxPrice?: number;
      assetClasses?: string[];
      maxAssets?: number;
      selectionFunction?: (context: AlgorithmContext) => Promise<Symbol[]>;
    }
  ) {}

  async selectUniverses(context: AlgorithmContext): Promise<Symbol[]> {
    if (this.options.selectionFunction) {
      return this.options.selectionFunction(context);
    }

    // Default selection based on criteria
    const selected: Symbol[] = [];

    context.securities.forEach((security, key) => {
      if (this.options.minVolume && security.volume < this.options.minVolume) {
        return;
      }
      if (this.options.minPrice && security.price < this.options.minPrice) {
        return;
      }
      if (this.options.maxPrice && security.price > this.options.maxPrice) {
        return;
      }
      if (this.options.assetClasses &&
          !this.options.assetClasses.includes(security.symbol.assetClass)) {
        return;
      }

      selected.push(security.symbol);
    });

    if (this.options.maxAssets && selected.length > this.options.maxAssets) {
      // Sort by volume and take top N
      return selected.slice(0, this.options.maxAssets);
    }

    return selected;
  }
}

/**
 * Scheduled Universe Selection
 * Rebalances universe at scheduled times
 */
export class ScheduledUniverseSelectionModel implements IUniverseSelectionModel {
  name = 'ScheduledUniverseSelection';
  private lastSelection: number = 0;
  private lastSymbols: Symbol[] = [];

  constructor(
    private baseModel: IUniverseSelectionModel,
    private intervalMs: number // Rebalance interval in milliseconds
  ) {}

  async selectUniverses(context: AlgorithmContext): Promise<Symbol[]> {
    const now = context.time;

    if (now - this.lastSelection >= this.intervalMs) {
      this.lastSymbols = await this.baseModel.selectUniverses(context);
      this.lastSelection = now;
    }

    return this.lastSymbols;
  }
}

// ============================================================================
// ALPHA MODEL
// ============================================================================

/**
 * Alpha Model
 * Generates trading signals (alphas)
 */
export interface IAlphaModel {
  name: string;
  update(context: AlgorithmContext, symbols: Symbol[]): Promise<Alpha[]>;
  onSecuritiesChanged?: (
    additions: Symbol[],
    removals: Symbol[]
  ) => Promise<void>;
}

/**
 * RSI Alpha Model
 * Generates signals based on RSI indicator
 */
export class RsiAlphaModel implements IAlphaModel {
  name = 'RSI Alpha';

  constructor(
    private options: {
      period?: number;
      oversoldThreshold?: number;
      overboughtThreshold?: number;
    } = {}
  ) {
    this.options = {
      period: 14,
      oversoldThreshold: 30,
      overboughtThreshold: 70,
      ...options,
    };
  }

  async update(context: AlgorithmContext, symbols: Symbol[]): Promise<Alpha[]> {
    const alphas: Alpha[] = [];

    for (const symbol of symbols) {
      const history = context.history(symbol, this.options.period! + 1, '1d');
      if (history.length < this.options.period! + 1) continue;

      // Calculate RSI
      const rsi = this.calculateRSI(history.map(h => h.close));

      if (rsi === null) continue;

      let direction: 'up' | 'down' | 'flat' = 'flat';
      let magnitude = 0;

      if (rsi < this.options.oversoldThreshold!) {
        direction = 'up';
        magnitude = 1 - (rsi / this.options.oversoldThreshold!);
      } else if (rsi > this.options.overboughtThreshold!) {
        direction = 'down';
        magnitude = (rsi - this.options.overboughtThreshold!) /
                    (100 - this.options.overboughtThreshold!);
      }

      alphas.push({
        symbol,
        direction,
        magnitude,
        confidence: Math.min(magnitude * 1.5, 1),
        source: this.name,
        timestamp: context.time,
      });
    }

    return alphas;
  }

  private calculateRSI(prices: number[]): number | null {
    if (prices.length < this.options.period! + 1) return null;

    let gains = 0;
    let losses = 0;

    for (let i = 1; i <= this.options.period!; i++) {
      const change = prices[i] - prices[i - 1];
      if (change > 0) {
        gains += change;
      } else {
        losses += Math.abs(change);
      }
    }

    const avgGain = gains / this.options.period!;
    const avgLoss = losses / this.options.period!;

    if (avgLoss === 0) return 100;

    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  }
}

/**
 * MACD Alpha Model
 * Generates signals based on MACD indicator
 */
export class MacdAlphaModel implements IAlphaModel {
  name = 'MACD Alpha';

  constructor(
    private options: {
      fastPeriod?: number;
      slowPeriod?: number;
      signalPeriod?: number;
    } = {}
  ) {
    this.options = {
      fastPeriod: 12,
      slowPeriod: 26,
      signalPeriod: 9,
      ...options,
    };
  }

  async update(context: AlgorithmContext, symbols: Symbol[]): Promise<Alpha[]> {
    const alphas: Alpha[] = [];
    const requiredPeriod = this.options.slowPeriod! + this.options.signalPeriod!;

    for (const symbol of symbols) {
      const history = context.history(symbol, requiredPeriod + 1, '1d');
      if (history.length < requiredPeriod + 1) continue;

      const prices = history.map(h => h.close);

      // Calculate EMAs
      const fastEMA = this.calculateEMA(prices, this.options.fastPeriod!);
      const slowEMA = this.calculateEMA(prices, this.options.slowPeriod!);

      // MACD Line
      const macdLine = fastEMA.map((f, i) => f - slowEMA[i]);

      // Signal Line
      const signalLine = this.calculateEMA(macdLine.slice(-this.options.slowPeriod!), this.options.signalPeriod!);

      if (macdLine.length < 2 || signalLine.length < 1) continue;

      const currentMACD = macdLine[macdLine.length - 1];
      const previousMACD = macdLine[macdLine.length - 2];
      const currentSignal = signalLine[signalLine.length - 1];

      // Generate signal based on MACD crossover
      let direction: 'up' | 'down' | 'flat' = 'flat';
      let magnitude = 0;

      // Bullish crossover
      if (previousMACD < currentSignal && currentMACD > currentSignal) {
        direction = 'up';
        magnitude = Math.min(Math.abs(currentMACD - currentSignal) / Math.abs(currentSignal + 0.001), 1);
      }
      // Bearish crossover
      else if (previousMACD > currentSignal && currentMACD < currentSignal) {
        direction = 'down';
        magnitude = Math.min(Math.abs(currentMACD - currentSignal) / Math.abs(currentSignal + 0.001), 1);
      }

      alphas.push({
        symbol,
        direction,
        magnitude,
        confidence: magnitude,
        source: this.name,
        timestamp: context.time,
      });
    }

    return alphas;
  }

  private calculateEMA(prices: number[], period: number): number[] {
    const multiplier = 2 / (period + 1);
    const ema: number[] = [];

    // First EMA is SMA
    let sum = 0;
    for (let i = 0; i < period && i < prices.length; i++) {
      sum += prices[i];
      ema.push(sum / (i + 1));
    }

    // Rest is EMA
    for (let i = period; i < prices.length; i++) {
      const currentEMA = (prices[i] - ema[i - 1]) * multiplier + ema[i - 1];
      ema.push(currentEMA);
    }

    return ema;
  }
}

/**
 * Composite Alpha Model
 * Combines multiple alpha models
 */
export class CompositeAlphaModel implements IAlphaModel {
  name = 'Composite Alpha';
  private models: IAlphaModel[];

  constructor(models: IAlphaModel[]) {
    this.models = models;
  }

  async update(context: AlgorithmContext, symbols: Symbol[]): Promise<Alpha[]> {
    const allAlphas: Alpha[] = [];

    for (const model of this.models) {
      const alphas = await model.update(context, symbols);
      allAlphas.push(...alphas);
    }

    // Combine alphas for same symbol
    return this.combineAlphas(allAlphas);
  }

  private combineAlphas(alphas: Alpha[]): Alpha[] {
    const combined = new Map<string, Alpha>();

    for (const alpha of alphas) {
      const key = alpha.symbol.ticker;
      const existing = combined.get(key);

      if (!existing) {
        combined.set(key, { ...alpha });
      } else {
        // Combine directions
        let netDirection = 0;
        netDirection += existing.direction === 'up' ? existing.magnitude :
                       existing.direction === 'down' ? -existing.magnitude : 0;
        netDirection += alpha.direction === 'up' ? alpha.magnitude :
                       alpha.direction === 'down' ? -alpha.magnitude : 0;

        existing.direction = netDirection > 0 ? 'up' : netDirection < 0 ? 'down' : 'flat';
        existing.magnitude = Math.abs(netDirection) / 2; // Average
        existing.confidence = (existing.confidence + alpha.confidence) / 2;
        existing.source = `${existing.source}+${alpha.source}`;
      }
    }

    return Array.from(combined.values());
  }
}

// ============================================================================
// PORTFOLIO CONSTRUCTION
// ============================================================================

/**
 * Portfolio Construction Model
 * Determines position sizes from alphas
 */
export interface IPortfolioConstructionModel {
  name: string;
  createTargets(
    context: AlgorithmContext,
    alphas: Alpha[]
  ): Promise<PortfolioTarget[]>;
}

/**
 * Equal Weight Portfolio Construction
 * Distributes capital equally among signals
 */
export class EqualWeightPortfolioConstruction implements IPortfolioConstructionModel {
  name = 'Equal Weight Portfolio';

  constructor(private maxPositions: number = 10) {}

  async createTargets(
    context: AlgorithmContext,
    alphas: Alpha[]
  ): Promise<PortfolioTarget[]> {
    const targets: PortfolioTarget[] = [];

    // Filter to only directional signals
    const directionalAlphas = alphas.filter(a => a.direction !== 'flat');

    // Sort by magnitude
    const sorted = directionalAlphas.sort((a, b) => b.magnitude - a.magnitude);

    // Take top N
    const selected = sorted.slice(0, this.maxPositions);

    if (selected.length === 0) return targets;

    const weight = 1 / selected.length;

    for (const alpha of selected) {
      const security = context.securities.get(alpha.symbol.ticker);
      if (!security) continue;

      const targetValue = context.portfolio.totalValue * weight;
      const quantity = alpha.direction === 'up'
        ? targetValue / security.price
        : -targetValue / security.price;

      targets.push({
        symbol: alpha.symbol,
        quantity,
        targetValue,
        targetWeight: weight,
        reason: `Equal weight (${(weight * 100).toFixed(1)}%) based on ${alpha.source}`,
      });
    }

    return targets;
  }
}

/**
 * Confidence Weighted Portfolio Construction
 * Weights positions by alpha confidence
 */
export class ConfidenceWeightedPortfolioConstruction implements IPortfolioConstructionModel {
  name = 'Confidence Weighted Portfolio';

  constructor(
    private maxPositions: number = 10,
    private minConfidence: number = 0.3
  ) {}

  async createTargets(
    context: AlgorithmContext,
    alphas: Alpha[]
  ): Promise<PortfolioTarget[]> {
    const targets: PortfolioTarget[] = [];

    // Filter directional and high confidence signals
    const filtered = alphas.filter(
      a => a.direction !== 'flat' && a.confidence >= this.minConfidence
    );

    // Sort by confidence
    const sorted = filtered.sort((a, b) => b.confidence - a.confidence);

    // Take top N
    const selected = sorted.slice(0, this.maxPositions);

    if (selected.length === 0) return targets;

    // Calculate total confidence
    const totalConfidence = selected.reduce((sum, a) => sum + a.confidence, 0);

    for (const alpha of selected) {
      const security = context.securities.get(alpha.symbol.ticker);
      if (!security) continue;

      const weight = alpha.confidence / totalConfidence;
      const targetValue = context.portfolio.totalValue * weight;
      const quantity = alpha.direction === 'up'
        ? targetValue / security.price
        : -targetValue / security.price;

      targets.push({
        symbol: alpha.symbol,
        quantity,
        targetValue,
        targetWeight: weight,
        reason: `Confidence weighted (${(weight * 100).toFixed(1)}%) based on ${alpha.source}`,
      });
    }

    return targets;
  }
}

/**
 * Mean-Variance Portfolio Construction
 * Optimizes weights using mean-variance optimization
 */
export class MeanVariancePortfolioConstruction implements IPortfolioConstructionModel {
  name = 'Mean-Variance Portfolio';

  constructor(private riskAversion: number = 2.5) {}

  async createTargets(
    context: AlgorithmContext,
    alphas: Alpha[]
  ): Promise<PortfolioTarget[]> {
    // This would integrate with the portfolio optimization module
    // For now, fallback to equal weight
    const equalWeight = new EqualWeightPortfolioConstruction();
    return equalWeight.createTargets(context, alphas);
  }
}

// ============================================================================
// RISK MANAGEMENT
// ============================================================================

/**
 * Risk Management Model
 * Applies risk controls to portfolio targets
 */
export interface IRiskManagementModel {
  name: string;
  manageRisk(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<PortfolioTarget[]>;
}

/**
 * Maximum Position Size Risk Management
 */
export class MaxPositionSizeRiskManagement implements IRiskManagementModel {
  name = 'Max Position Size Risk';

  constructor(private maxPositionPercent: number = 0.10) {}

  async manageRisk(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<PortfolioTarget[]> {
    const adjustedTargets: PortfolioTarget[] = [];
    const maxPositionValue = context.portfolio.totalValue * this.maxPositionPercent;

    for (const target of targets) {
      const security = context.securities.get(target.symbol.ticker);
      if (!security) continue;

      const positionValue = Math.abs(target.quantity * security.price);

      if (positionValue > maxPositionValue) {
        const adjustedQuantity = (maxPositionValue / security.price) *
                                 Math.sign(target.quantity);

        adjustedTargets.push({
          ...target,
          quantity: adjustedQuantity,
          targetValue: maxPositionValue,
          reason: `${target.reason} (limited to ${(this.maxPositionPercent * 100).toFixed(0)}% max position)`,
        });
      } else {
        adjustedTargets.push(target);
      }
    }

    return adjustedTargets;
  }
}

/**
 * Maximum Drawdown Risk Management
 */
export class MaxDrawdownRiskManagement implements IRiskManagementModel {
  name = 'Max Drawdown Risk';
  private peakValue: number = 0;

  constructor(
    private maxDrawdown: number = 0.20,
    private reductionFactor: number = 0.5
  ) {}

  async manageRisk(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<PortfolioTarget[]> {
    const currentValue = context.portfolio.totalValue;

    // Update peak
    if (currentValue > this.peakValue) {
      this.peakValue = currentValue;
    }

    // Calculate current drawdown
    const drawdown = this.peakValue > 0
      ? (this.peakValue - currentValue) / this.peakValue
      : 0;

    // If approaching max drawdown, reduce positions
    if (drawdown >= this.maxDrawdown * 0.8) {
      return targets.map(target => ({
        ...target,
        quantity: target.quantity * this.reductionFactor,
        reason: `${target.reason} (reduced due to drawdown: ${(drawdown * 100).toFixed(1)}%)`,
      }));
    }

    return targets;
  }
}

/**
 * Composite Risk Management
 * Applies multiple risk models in sequence
 */
export class CompositeRiskManagement implements IRiskManagementModel {
  name = 'Composite Risk Management';
  private models: IRiskManagementModel[];

  constructor(models: IRiskManagementModel[]) {
    this.models = models;
  }

  async manageRisk(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<PortfolioTarget[]> {
    let adjustedTargets = targets;

    for (const model of this.models) {
      adjustedTargets = await model.manageRisk(context, adjustedTargets);
    }

    return adjustedTargets;
  }
}

// ============================================================================
// EXECUTION MODEL
// ============================================================================

/**
 * Execution Model
 * Executes trades efficiently
 */
export interface IExecutionModel {
  name: string;
  execute(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<Order[]>;
}

/**
 * Immediate Execution Model
 * Executes all trades immediately at market
 */
export class ImmediateExecutionModel implements IExecutionModel {
  name = 'Immediate Execution';

  async execute(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<Order[]> {
    const orders: Order[] = [];

    for (const target of targets) {
      const security = context.securities.get(target.symbol.ticker);
      if (!security) continue;

      const order: Order = {
        id: `order-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        symbol: target.symbol,
        type: 'market',
        side: target.quantity > 0 ? 'buy' : 'sell',
        quantity: Math.abs(target.quantity),
        timeInForce: 'GTC',
        status: 'pending',
        filledQuantity: 0,
        filledPrice: 0,
        timestamp: context.time,
        tag: target.reason,
      };

      orders.push(order);
    }

    return orders;
  }
}

/**
 * Limit Order Execution Model
 * Uses limit orders for better fills
 */
export class LimitOrderExecutionModel implements IExecutionModel {
  name = 'Limit Order Execution';

  constructor(
    private limitOffsetPercent: number = 0.001 // 0.1% better than current price
  ) {}

  async execute(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<Order[]> {
    const orders: Order[] = [];

    for (const target of targets) {
      const security = context.securities.get(target.symbol.ticker);
      if (!security) continue;

      const isBuy = target.quantity > 0;
      const basePrice = isBuy ? security.ask : security.bid;
      const limitPrice = isBuy
        ? basePrice * (1 - this.limitOffsetPercent)
        : basePrice * (1 + this.limitOffsetPercent);

      const order: Order = {
        id: `order-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        symbol: target.symbol,
        type: 'limit',
        side: isBuy ? 'buy' : 'sell',
        quantity: Math.abs(target.quantity),
        price: limitPrice,
        timeInForce: 'GTC',
        status: 'pending',
        filledQuantity: 0,
        filledPrice: 0,
        timestamp: context.time,
        tag: target.reason,
      };

      orders.push(order);
    }

    return orders;
  }
}

/**
 * TWAP Execution Model
 * Time-Weighted Average Price execution
 */
export class TwapExecutionModel implements IExecutionModel {
  name = 'TWAP Execution';

  private pendingOrders: Map<string, { target: PortfolioTarget; remaining: number; slices: number }> = new Map();

  constructor(
    private sliceCount: number = 5,
    private sliceIntervalMs: number = 60000 // 1 minute between slices
  ) {}

  async execute(
    context: AlgorithmContext,
    targets: PortfolioTarget[]
  ): Promise<Order[]> {
    const orders: Order[] = [];

    for (const target of targets) {
      const security = context.securities.get(target.symbol.ticker);
      if (!security) continue;

      const key = target.symbol.ticker;
      const existing = this.pendingOrders.get(key);

      if (!existing) {
        // New target - initialize slicing
        this.pendingOrders.set(key, {
          target,
          remaining: Math.abs(target.quantity),
          slices: 0,
        });
      }

      const pending = this.pendingOrders.get(key);
      if (!pending) continue;

      // Execute next slice
      if (pending.slices < this.sliceCount && pending.remaining > 0) {
        const sliceSize = pending.target.quantity / this.sliceCount;

        const order: Order = {
          id: `order-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          symbol: target.symbol,
          type: 'market',
          side: sliceSize > 0 ? 'buy' : 'sell',
          quantity: Math.abs(sliceSize),
          timeInForce: 'IOC',
          status: 'pending',
          filledQuantity: 0,
          filledPrice: 0,
          timestamp: context.time,
          tag: `TWAP slice ${pending.slices + 1}/${this.sliceCount}`,
        };

        orders.push(order);
        pending.slices++;
        pending.remaining -= Math.abs(sliceSize);

        if (pending.remaining <= 0) {
          this.pendingOrders.delete(key);
        }
      }
    }

    return orders;
  }
}

// ============================================================================
// ALGORITHM FRAMEWORK
// ============================================================================

/**
 * Algorithm Framework
 * Main class that orchestrates all components
 */
export class AlgorithmFramework {
  private universeSelection: IUniverseSelectionModel;
  private alphaModel: IAlphaModel;
  private portfolioConstruction: IPortfolioConstructionModel;
  private riskManagement: IRiskManagementModel;
  private executionModel: IExecutionModel;

  private currentSymbols: Symbol[] = [];
  private previousSymbols: Symbol[] = [];

  constructor(options: {
    universeSelection: IUniverseSelectionModel;
    alphaModel: IAlphaModel;
    portfolioConstruction: IPortfolioConstructionModel;
    riskManagement: IRiskManagementModel;
    executionModel: IExecutionModel;
  }) {
    this.universeSelection = options.universeSelection;
    this.alphaModel = options.alphaModel;
    this.portfolioConstruction = options.portfolioConstruction;
    this.riskManagement = options.riskManagement;
    this.executionModel = options.executionModel;
  }

  /**
   * Run one step of the algorithm
   */
  async step(context: AlgorithmContext): Promise<Order[]> {
    // 1. Universe Selection
    this.previousSymbols = this.currentSymbols;
    this.currentSymbols = await this.universeSelection.selectUniverses(context);

    // Handle universe changes
    if (this.universeSelection.onSecuritiesChanged) {
      const additions = this.currentSymbols.filter(
        s => !this.previousSymbols.some(p => p.ticker === s.ticker)
      );
      const removals = this.previousSymbols.filter(
        s => !this.currentSymbols.some(c => c.ticker === s.ticker)
      );

      if (additions.length > 0 || removals.length > 0) {
        await this.universeSelection.onSecuritiesChanged(additions, removals);
      }
    }

    // 2. Alpha Generation
    const alphas = await this.alphaModel.update(context, this.currentSymbols);

    // 3. Portfolio Construction
    let targets = await this.portfolioConstruction.createTargets(context, alphas);

    // 4. Risk Management
    targets = await this.riskManagement.manageRisk(context, targets);

    // 5. Execution
    const orders = await this.executionModel.execute(context, targets);

    return orders;
  }

  /**
   * Get current symbols
   */
  getSymbols(): Symbol[] {
    return this.currentSymbols;
  }
}

// ============================================================================
// PRESETS
// ============================================================================

/**
 * Create a conservative strategy framework
 */
export function createConservativeFramework(): AlgorithmFramework {
  return new AlgorithmFramework({
    universeSelection: new DynamicUniverseSelectionModel({
      minVolume: 1000000,
      maxAssets: 10,
    }),
    alphaModel: new CompositeAlphaModel([
      new RsiAlphaModel({ period: 14, oversoldThreshold: 25, overboughtThreshold: 75 }),
      new MacdAlphaModel(),
    ]),
    portfolioConstruction: new ConfidenceWeightedPortfolioConstruction(10, 0.5),
    riskManagement: new CompositeRiskManagement([
      new MaxPositionSizeRiskManagement(0.05),
      new MaxDrawdownRiskManagement(0.15, 0.5),
    ]),
    executionModel: new LimitOrderExecutionModel(0.002),
  });
}

/**
 * Create an aggressive strategy framework
 */
export function createAggressiveFramework(): AlgorithmFramework {
  return new AlgorithmFramework({
    universeSelection: new DynamicUniverseSelectionModel({
      minVolume: 500000,
      maxAssets: 20,
    }),
    alphaModel: new CompositeAlphaModel([
      new RsiAlphaModel({ period: 7, oversoldThreshold: 30, overboughtThreshold: 70 }),
      new MacdAlphaModel({ fastPeriod: 8, slowPeriod: 17, signalPeriod: 9 }),
    ]),
    portfolioConstruction: new EqualWeightPortfolioConstruction(20),
    riskManagement: new MaxPositionSizeRiskManagement(0.15),
    executionModel: new ImmediateExecutionModel(),
  });
}

// Export all
const algorithmFramework = {
  // Core
  AlgorithmFramework,

  // Universe Selection
  ManualUniverseSelectionModel,
  DynamicUniverseSelectionModel,
  ScheduledUniverseSelectionModel,

  // Alpha Models
  RsiAlphaModel,
  MacdAlphaModel,
  CompositeAlphaModel,

  // Portfolio Construction
  EqualWeightPortfolioConstruction,
  ConfidenceWeightedPortfolioConstruction,
  MeanVariancePortfolioConstruction,

  // Risk Management
  MaxPositionSizeRiskManagement,
  MaxDrawdownRiskManagement,
  CompositeRiskManagement,

  // Execution
  ImmediateExecutionModel,
  LimitOrderExecutionModel,
  TwapExecutionModel,

  // Presets
  createConservativeFramework,
  createAggressiveFramework,
};

export default algorithmFramework;
